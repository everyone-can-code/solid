[
{
	"uri": "//localhost/solid/srp/",
	"title": "SRP (Single Responsibility Principle)",
	"tags": [],
	"description": "SRP (Single Responsibility Principle)",
	"content": " SRP (Single Responsibility Principle) The single responsibility principle is a computer programming principle that states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility.\nThe principle of SRP can be used when:  too much is allowed to the class object\n any change in the logic of the object\u0026rsquo;s behavior leads to changes in other places of the application\n you have to test, fix errors, even if a third party is responsible for their performance\n not so simple to separate and apply a class in another area of the application, since it will pull unnecessary dependencies\n  Bad: Good: Read More:  https://github.com/SanderV1992/SOLID-examples/tree/master/src/srp/good https://ru.wikipedia.org/  "
},
{
	"uri": "//localhost/solid/ocp/",
	"title": "OCP (Open Closed Principle)",
	"tags": [],
	"description": "OCP (Open Closed Principle)",
	"content": " OCP (Open Closed Principle) Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.\nThe principle of OCP suggests that software entities must be:  should be open for extension: this means, that module can be extended. When applications requirements change, we are able to expand the module.\nIn other words, we have the ability to extend classes, making them more functional. At the same time, the behavior of the old methods does not change, and class itself is not changing to.\n closed for modification: after the expansion of the entity behavior, no changes should be made to the code that uses these entities.\n  This is especially important for code in a production environment:  any changes in the source code requires a revision of the entire code, where this entity / class is used.\n revision of unit testing and other similar procedures.\n  If code follows this principle, therefore does not require such effort.\nRead More:  https://github.com/SanderV1992/SOLID-examples/tree/master/src/ocp/good https://ru.wikipedia.org/  "
},
{
	"uri": "//localhost/solid/lsp/",
	"title": "LSP (Liskov Substitution Principle)",
	"tags": [],
	"description": "LSP (Liskov Substitution Principle)",
	"content": " LSP (Liskov Substitution Principle) Liskov\u0026rsquo;s notion of a behavioural subtype defines a notion of substitutability for objects; that is, if S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program (e.g. correctness).\nThe LSP principles are followed in the following cases:   No new exceptions should be thrown by methods of the subtype, except where those exceptions are themselves subtypes of exceptions thrown by the methods of the supertype. does not violate the functionality returns the same type subclass object has a contract with a superclass  The LSP principle is violated in the following cases:  the parent class in the method calls some kind of external service, and the child completely rewrites the method.  Read More:  https://github.com/SanderV1992/SOLID-examples/tree/master/src/lsp/good https://dou.ua/lenta/articles/liskov-substitution-principle/ https://ru.wikipedia.org/  "
},
{
	"uri": "//localhost/solid/isp/",
	"title": "ISP (Interface segregation principle)",
	"tags": [],
	"description": "ISP (Interface segregation principle)",
	"content": " ISP (Interface segregation principle) following this principle helps the system stay flexible when making changes to the logic of work and suitable for refactoring.\nNo any client should be forced to depend on methods it does not use.\nISP splits interfaces that are very large into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them. Such shrunken interfaces are also called role interfaces. ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy.\nRead More:  https://github.com/SanderV1992/SOLID-examples/tree/master/src/isp/good  "
},
{
	"uri": "//localhost/solid/dip/",
	"title": "DIP (Dependency Inversion Principle)",
	"tags": [],
	"description": "DIP (Dependency Inversion Principle)",
	"content": " DIP (Dependency Inversion Principle) Dependency inversion talks about the coupling between the different classes or modules.\nThe main motto of the dependency inversion is Any higher classes should always depend upon the abstraction of the class rather than the detail.\nThis aims to reduce the coupling between the classes is achieved by introducing abstraction between the layer, thus doesn’t care about the real implementation.\nThe principle states:  High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.  Now let’s see how a naive design would look without any dependency inversion and what are the loopholes in that design: The creation of the abstraction between different employees and Manager has resulted in very good looking design code which is easily maintainable and extendable: Read More:  https://github.com/SanderV1992/SOLID-examples/tree/master/src/dip/good https://www.geeksforgeeks.org/dependecy-inversion-principle-solid/  "
},
{
	"uri": "//localhost/solid/",
	"title": "5 SOLID Principles of Object-oriented Design",
	"tags": [],
	"description": "",
	"content": " 5 SOLID Principles of Object-oriented Design S (Single-responsiblity principle) One class should have one and only one responsibility\nO (Open-closed principle) Objects or entities should be open for extension, but closed for modification.\nL (Liskov substitution principle) Derived types must be completely substitutable for their base types.\nI (Interface segregation principle) Objects or entities should be open for extension, but closed for modification.\nD (Dependency Inversion Principle) Entities must depend on abstractions not on concretions.\nRead More:  https://www.slideshare.net/ptsukanov/solid-12138776 https://github.com/SanderV1992/SOLID-examples  "
},
{
	"uri": "//localhost/solid/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost/solid/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]